{"version":3,"sources":["_mosh.js"],"names":[],"mappings":"AAAA","file":"scripts.min.js","sourcesContent":["///*\n//\n//    ____  __  ______  __________  __  _______  _____ __  __\n//   / __ \\/ / / / __ \\/_  __/ __ \\/  |/  / __ \\/ ___// / / /\n//  / /_/ / /_/ / / / / / / / / / / /|_/ / / / /\\__ \\/ /_/ /\n// / ____/ __  / /_/ / / / / /_/ / /  / / /_/ /___/ / __  /\n///_/   /_/ /_/\\____/ /_/  \\____/_/  /_/\\____//____/_/ /_/\n//\n//PHOTOMOSH (c) 2018 by Airtight Interactive / Felix Turner\n//www.airtight.cc / @felixturner\n//\n//*/\n//\n///*\n//    MOSH Main\n//*/\n//\n///* global Events, ImprovedNoise , $ , THREE , TweenMax , Stats */\n//\n//var MOSH = { VERSION : '1.0.0'  };\n//MOSH.events = new Events();\n//MOSH.noise = new ImprovedNoise();\n//\n//MOSH.Main = function () {\n//\n//    var isDev;\n//    var isMobile;\n//    var camera, scene, renderer;\n//    var planeMaterial;\n//    var plane;\n//    var $logo;\n//    var stats;\n//    var renderSize = new THREE.Vector2(); //dims of renderer\n//    var maxRenderDims = {\n//        jpg: 2048,\n//        webm: 1280,\n//        gif: 640\n//    };\n//\n//    function init() {\n//\n//        console.log('PHOTOMOSH ' + MOSH.VERSION);\n//\n//        isDev = window.location.href.indexOf('?dev') > -1;\n//        isMobile = !!('ontouchstart' in window);\n//        //override mobile\n//        if(window.location.href.indexOf('mobile')> -1){\n//            isMobile = true;\n//        }\n//\n//        //test for webgl\n//        if (!hasWebGL()) {\n//            $('#input-options').css('display', 'none');\n//            $('#file-prompt').css('display', 'none');\n//            TweenMax.to($('#cam-prompt'), 0.6, { autoAlpha: 1 });\n//            $('#cam-prompt').html('This browser or device does not support WebGL.<br>Find out how to get WebGL <a href=\"http://get.webgl.org/\">here</a>.');\n//        }\n//\n//\n//        $('#btn-mosh').on('click', MOSH.FX.randomizeFilters);\n//\n//        // stop the user getting a text cursor\n//        document.onselectstart = function () {\n//            return false;\n//        };\n//\n//        //fade in\n//        TweenMax.to($('#intro'), 1.5, { opacity: 1 });\n//\n//        //init 3D\n//        camera = new THREE.PerspectiveCamera(75, 1080 / 720, 1, 3000);\n//        camera.position.z = 65;\n//        scene = new THREE.Scene();\n//\n//        //Add image plane\n//        planeMaterial = new THREE.MeshBasicMaterial();\n//        var planeGeometry = new THREE.PlaneBufferGeometry(100, 100, 1, 1);\n//        plane = new THREE.Mesh(planeGeometry, planeMaterial);\n//        scene.add(plane);\n//\n//        //STATS\n//        stats = new Stats();\n//        if (isDev) document.body.append(stats.domElement);\n//        stats.domElement.id = 'stats';\n//\n//        //init renderer\n//        renderer = new THREE.WebGLRenderer({\n//            preserveDrawingBuffer: true\n//        });\n//        $('#webgl').append(renderer.domElement);\n//\n//        MOSH.FX.init();\n//        MOSH.Recorder.init();\n//        MOSH.Input.init();\n//\n//        window.addEventListener('resize', onResize, false);\n//        $(document).on('keydown', onKeyDown, false);\n//\n//        onResize();\n//\n//        $logo = $('#intro-logo');\n//\n//    }\n//\n//    //////////////////////\n//    //ANIMATE\n//    //////////////////////\n//    function update() {\n//        requestAnimationFrame(update);\n//        $logo.css('opacity', Math.random() + 0.5);\n//        if (!MOSH.Input.getSourceReady()) return;\n//        MOSH.events.emit('update');\n//        stats.update();\n//    }\n//\n//    //////////////////////\n//    //RESIZE\n//    //////////////////////\n//    function onResize() {\n//\n//        if (!MOSH.Input.getSourceReady()) return;\n//        var srcSize = MOSH.Input.getSourceSize();\n//        var sourceAspect = srcSize.x / srcSize.y;\n//\n//        var mrd = maxRenderDims[MOSH.Recorder.getRecordMode()];\n//\n//        //use source size for webgl render size and output\n//        renderSize.copy(srcSize);\n//        renderSize.x = Math.round(renderSize.x);\n//        renderSize.y = Math.round(renderSize.y);\n//\n//        //cap max render size\n//        if (renderSize.x > mrd){\n//            renderSize.x = mrd;\n//            renderSize.y = Math.floor(mrd / sourceAspect);\n//        }\n//\n//        if (renderSize.y > mrd){\n//            renderSize.y = mrd;\n//            renderSize.x = Math.floor(mrd * sourceAspect);\n//        }\n//        //console.log('srcSize', srcSize)\n//        //console.log('mrd', mrd);\n//        //console.log('renderSize', renderSize)\n//\n//        if (renderSize.x > 0) {\n//            camera.aspect = renderSize.x / renderSize.y;\n//            camera.updateProjectionMatrix();\n//            renderer.setSize(renderSize.x, renderSize.y);\n//        }\n//\n//        //resize img plane fit viewport\n//        //make plane fill renderer\n//        plane.scale.x = camera.aspect;\n//\n//        //scale renderer to fit in VP via CSS\n//        //resize renderer to match sourceSize aspect ratio and fit\n//        var vpSize = new THREE.Vector2($('#viz').width(), $('#viz').height());\n//\n//        //add padding\n//        var PADDING = 20;\n//        vpSize.x -= PADDING;\n//        vpSize.y -= PADDING;\n//\n//        var vpAspect = vpSize.x / vpSize.y;\n//        var viewSize = new THREE.Vector2();\n//        var viewScl = new THREE.Vector2();\n//\n//        if (sourceAspect > vpAspect) {\n//            viewSize.x = Math.min(vpSize.x,renderSize.x); //dont go bigger than original\n//            viewSize.y = viewSize.x / sourceAspect;\n//        } else {\n//            viewSize.y = Math.min(vpSize.y,renderSize.y);\n//            viewSize.x = viewSize.y * sourceAspect;\n//        }\n//\n//        viewScl.x = viewSize.x/renderSize.x;\n//        viewScl.y = viewSize.y/renderSize.y;\n//\n//        var viewOffset = new THREE.Vector2(Math.floor((vpSize.x - viewSize.x) / 2), Math.floor((vpSize.y - viewSize.y) / 2));\n//\n//        viewOffset.x += PADDING/2;\n//        viewOffset.y += PADDING/2;\n//\n//        // console.log('renderSize',renderSize);\n//        // console.log('vpSize',vpSize);\n//        // console.log('viewScl', viewScl);\n//        // console.log('viewOffset',viewOffset);\n//\n//        // scale and center renderer inside Viewport\n//        TweenMax.set('#webgl', {scaleX:viewScl.x, scaleY:viewScl.y, x: viewOffset.x, y: viewOffset.y});\n//        //keep prog bar fixed height\n//        TweenMax.set('#progress-bar', {scaleY:1/viewScl.y});\n//        TweenMax.set('#progress-bar-bkgnd', { scaleY:1/viewScl.y});\n//\n//\n//        MOSH.events.emit('resize');\n//    }\n//\n//    function updateMaterial(texture){\n//        planeMaterial.map = texture;\n//        planeMaterial.needsUpdate = true;\n//        onResize();\n//    }\n//\n//    function trace(text) {\n//        $('#debug-text').text(text);\n//    }\n//\n//    function onKeyDown(event) {\n//\n//        switch (event.keyCode) {\n//            case 32: /* SPACE */\n//                MOSH.FX.randomizeFilters();\n//                break;\n//        }\n//    }\n//\n//    function hasWebGL() {\n//        try { return !!window.WebGLRenderingContext && !!document.createElement('canvas').getContext('experimental-webgl'); } catch (e) { return false; }\n//    }\n//\n//    return {\n//        init: init,\n//        update: update,\n//        trace: trace,\n//        getCamera: function() { return camera;},\n//        getScene: function() { return scene;},\n//        getRenderer: function() { return renderer;},\n//        getIsMobile: function() { return isMobile;},\n//        renderSize: renderSize,\n//        onResize: onResize,\n//        updateMaterial: updateMaterial\n//    };\n//\n//}();\n//\n//\n//$(document).ready(function () {\n//    MOSH.Main.init();\n//});\n//\n///*\n//\n//    Mosh.FX\n//    Handles PPO, creating FX panel, passes\n//\n//*/\n//\n///* global $ , THREE , MOSH , dat , ATUtil */\n//\n//\n//MOSH.FX = function () {\n//\n//    var composer;\n//    var renderPass, copyPass;\n//    var gui;\n//    var filters;  //object containing named parameter objects from filters.json\n//    var passes; //object containing named ShaderPasses\n//\n//    var luts = [];\n//    var lutNames = ['lookup_miss_etikate.png',\n//        'lookup_amatorka.png',\n//        'lookup_soft_elegance_1.png',\n//        'lookup_soft_elegance_2.png'];\n//\n//    function init(){\n//\n//        var imgLdr = new THREE.TextureLoader();\n//\n//        //EVENT HANDLERS\n//        MOSH.events.on('update', update);\n//        MOSH.events.on('resize', onResize);\n//\n//        //POST PROCESSING\n//        //Create Shader Passes\n//        renderPass = new THREE.RenderPass( MOSH.Main.getScene(), MOSH.Main.getCamera() );\n//        copyPass = new THREE.ShaderPass(THREE.CopyShader);\n//\n//        //object based look up\n//        passes = {};\n//        passes.badtv = new THREE.ShaderPass(THREE.BadTVShader);\n//        passes.rgb = new THREE.ShaderPass(THREE.RGBShiftShader);\n//        passes.pixelate = new THREE.ShaderPass(THREE.PixelateShader);\n//        passes.slices = new THREE.ShaderPass(THREE.SlicesShader);\n//        passes.dotmatrix = new THREE.ShaderPass(THREE.DotMatrixShader);\n//        passes.scanlines = new THREE.ShaderPass(THREE.ScanlinesShader);\n//        passes.vignette = new THREE.ShaderPass(THREE.VignetteShader);\n//        passes.mirror = new THREE.ShaderPass(THREE.MirrorShader);\n//        passes.dotscreen = new THREE.ShaderPass(THREE.DotScreenShader);\n//        passes.lut = new THREE.ShaderPass(THREE.LUTShader);\n//        passes.glow = new THREE.ShaderPass(THREE.GlowShader);\n//        passes.posterize = new THREE.ShaderPass(THREE.PosterizeShader);\n//        passes.huesat = new THREE.ShaderPass(THREE.HueSaturationShader);\n//        passes.brightness = new THREE.ShaderPass(THREE.BrightnessContrastShader);\n//        passes.polar = new THREE.ShaderPass(THREE.PolarPixelateShader);\n//        passes.edges = new THREE.ShaderPass(THREE.EdgeShader);\n//        passes.tilt = new THREE.ShaderPass(THREE.VerticalTiltShiftShader);\n//        passes.wobble = new THREE.ShaderPass(THREE.WobbleShader);\n//        passes.smear = new THREE.ShaderPass( THREE.SmearShader );\n//        passes.barrelBlur = new THREE.ShaderPass(THREE.BarrelBlurShader);\n//        passes.glitcher = new THREE.ShaderPass(THREE.GlitcherShader);\n//        passes.noiseDisplace = new THREE.ShaderPass(THREE.NoiseDisplaceShader);\n//        passes.duoTone = new THREE.ShaderPass(THREE.DuoToneShader);\n//        passes.rainbow = new THREE.ShaderPass(THREE.RainbowShader);\n//        passes.solarize = new THREE.ShaderPass(THREE.SolarizeShader);\n//        passes.linocut = new THREE.ShaderPass(THREE.LinocutShader);\n//\n//        //grave yard\n//        //passes.lines = new THREE.ShaderPass(THREE.LinesShader);\n//        //passes.noise = new THREE.ShaderPass(THREE.NoiseShader);\n//        //passes.strobe = new THREE.ShaderPass(THREE.StrobeShader);\n//\n//        //init LUTs\n//        for (var i = 0; i < lutNames.length; i++) {\n//            var lookupTexture = imgLdr.load('res/lut/' + lutNames[i]);\n//            lookupTexture.genMipmaps = false;\n//            lookupTexture.minFilter = THREE.LinearFilter;\n//            lookupTexture.magFilter = THREE.LinearFilter;\n//            lookupTexture.wrapS = THREE.ClampToEdgeWrapping;\n//            lookupTexture.wrapT = THREE.ClampToEdgeWrapping;\n//            luts.push(lookupTexture);\n//        }\n//\n//        passes.lut.uniforms.lookupTable.value = luts[0];\n//\n//        //INIT UI\n//        gui = new dat.GUI({ autoPlace: false });\n//        $('#settings').append(gui.domElement);\n//        //gui.close();\n//\n//        //LOAD params\n//        $.ajax({\n//            type: 'GET',\n//            dataType: 'json',\n//            url: 'res/json/filters.json',\n//            success: initFilters,\n//        });\n//\n//    }\n//\n//    function initFilters(data) {\n//\n//        filters = data.filters;\n//        //create UI from params JSON\n//        var folder;\n//        $.each(filters, function (i, filter) {\n//\n//            //create folder\n//            folder = gui.addFolder(filter.displayName);\n//\n//            //create toogle boolean\n//            folder.add(filter, 'on').listen().onChange(onToggleShaders);\n//\n//            if (filter.on) folder.open();\n//\n//            //add slider for each param\n//            $.each(filter.params, function (i, param) {\n//\n//                //dont surface automated params\n//                if (param.automate) return true;\n//\n//                if (param.type === 'color'){\n//\n//                    folder.addColor(param, 'value').listen().name(param.displayName).onChange(onParamsChange);\n//\n//                }else{\n//\n//                    folder.add(param, 'value', param.min, param.max).step(param.step).listen().name(param.displayName).onChange(onParamsChange);\n//\n//                    var range;\n//                    //TODO - may be cleaner just to set randMin and randMax in filters json\n//                    if (param.randRange === 'high') {\n//\n//                        //select from top 25% of range\n//                        range = param.max - param.min;\n//                        param.randMin = param.min + range * 0.75;\n//                        param.randMax = param.max;\n//\n//                    } else if (param.randRange === 'low') {\n//                        //select from bottom 25% of range\n//                        range = param.max - param.min;\n//                        param.randMin = param.min;\n//                        param.randMax = param.min + range * 0.4;\n//\n//                    } else {\n//                        param.randMin = param.min;\n//                        param.randMax = param.max;\n//                    }\n//                }\n//\n//            });\n//\n//            filter.folder = folder;\n//\n//        });\n//\n//\n//        //init custom params\n//\n//        //ADD EXTRA GUI\n//\n//        onToggleShaders();\n//        onParamsChange();\n//\n//        //FIXME\n//        MOSH.Main.update();\n//    }\n//\n//    function onParamsChange() {\n//\n//        //console.log(filters);\n//\n//        //copy gui params into shader uniforms\n//        $.each(filters, function (i, filter) {\n//            $.each(filter.params, function (j, param) {\n//\n//                //DEBUG\n//                //console.log(i,j);\n//\n//                if (param.custom) return true;\n//\n//                if (param.type === 'color'){\n//                    passes[i].uniforms[j].value = new THREE.Color(param.value);\n//                }else{\n//                    passes[i].uniforms[j].value = param.value;\n//                }\n//            });\n//\n//        });\n//\n//        //custom param setting\n//        passes.lut.uniforms.lookupTable.value = luts[Math.floor(filters.lut.params.mode.value)];\n//\n//    }\n//\n//\n//    //var origFBO, savePass;\n//\n//    function onToggleShaders() {\n//\n//        //console.log('onToggleShaders', renderSize.x);\n//\n//        //SAVE ORIG IMG?????\n//        // var renderTargetParameters = {\n//        // \tminFilter: THREE.LinearFilter,\n//        // \tformat: THREE.RGBFormat,\n//        // \tstencilBuffer: false,\n//        // \tdepthBuffer: false\n//        // };\n//\n//        //origFBO = new THREE.WebGLRenderTarget( renderSize.x, renderSize.y, renderTargetParameters ) ;\n//        //savePass = new THREE.SavePass(origFBO);//\n//        //console.log(fbo);\n//\n//        //Add Shader Passes to Composer\n//        //order defined by filters.json\n//        composer = new THREE.EffectComposer(MOSH.Main.getRenderer());\n//        composer.addPass(renderPass);\n//        //composer.addPass( savePass );\n//\n//        $.each(filters, function (i, filter) {\n//            if (filter.on) {\n//                composer.addPass(passes[i]);\n//            }\n//        });\n//\n//        //passes.smear.uniforms.tOrig.value = origFBO.texture;\n//\n//        composer.addPass(copyPass);\n//        copyPass.renderToScreen = true;\n//\n//        onResize();\n//        //composer.setSize(MOSH.Main.renderSize.x, MOSH.Main.renderSize.y);\n//    }\n//\n//    function randomizeFilters() {\n//\n//        //clear all filters\n//        $.each(filters, function (i, filter) {\n//            filter.on = false;\n//            filter.folder.close();\n//        });\n//\n//        //console.log('---------------');\n//        //console.log('filters:', filters);\n//\n//        var keys = Object.keys(filters);\n//        var len = keys.length;\n//\n//        //turn on 3 filters\n//        for (var i = 0; i < 3; i++) {\n//\n//            var r = ATUtil.randomInt(0, len - 1);\n//            filters[keys[r]].on = true;\n//\n//            //console.log(filters[r].displayName);\n//            //open enabled folders\n//            filters[keys[r]].folder.open();\n//        }\n//\n//        //RANDOMIZE ALL PARAMS\n//        $.each(filters, function (i, filter) {\n//            $.each(filter.params, function (j, param) {\n//\n//                if (param.type !== 'color'){\n//                    param.value = ATUtil.randomRange(param.randMin, param.randMax);\n//                }\n//            });\n//        });\n//\n//        onToggleShaders();\n//        onParamsChange();\n//\n//    }\n//\n//    function update() {\n//\n//        //pt goes from 0 -1 over videoDuration\n//        var pt = performance.now() / (MOSH.Recorder.getVideoDuration() * 1000);\n//\n//        //loop over pt\n//        passes.wobble.uniforms.time.value = pt;\n//        passes.slices.uniforms.time.value = pt;\n//        passes.rainbow.uniforms.time.value = pt;\n//        passes.badtv.uniforms.time.value = pt;\n//        passes.smear.uniforms.time.value = pt;\n//\n//        //time used for rands\n//        passes.scanlines.uniforms.time.value = pt;\n//        passes.barrelBlur.uniforms.time.value = pt;\n//\n//        //time used for speeds\n//        passes.glitcher.uniforms.time.value = pt;\n//        passes.noiseDisplace.uniforms.time.value = pt;\n//\n//        //automate RGB angle\n//        passes.rgb.uniforms.angle.value = (MOSH.noise.noise(pt, 99, 0) + 0.5) * 6.28;\n//        passes.huesat.uniforms.hue.value = MOSH.noise.noise(pt * 2, 999, 0) * 2;\n//\n//        composer.render(0.1);\n//\n//    }\n//\n//    function onResize(){\n//\n//        if (composer) {\n//            composer.setSize(MOSH.Main.renderSize.x, MOSH.Main.renderSize.y);\n//        }\n//\n//        passes.scanlines.uniforms.height.value = MOSH.Main.renderSize.y;\n//        passes.linocut.uniforms.resolution.value = MOSH.Main.renderSize;\n//    }\n//\n//\n//    return {\n//        init:init,\n//        onResize: onResize,\n//        randomizeFilters: randomizeFilters,\n//        getComposer: function() { return composer;},\n//    };\n//\n//}();\n//\n///*\n//    MOSH.Input\n//    Handle file input & webcam\n//*/\n//\n///* global Events, ImprovedNoise , $ , THREE , TweenMax , Stats , MOSH */\n//\n//\n//MOSH.Input = function () {\n//\n//    var sourceReady = false; //is image or webcam loaded?\n//    var sourceSize = new THREE.Vector2(); //dims of webcam video or dropped image as Vector2\n//    var videoIn = document.createElement('video');\n//    var inputTexture;\n//\n//    function init() {\n//\n//        $('#option-cam').on('click', selectCam);\n//        $('#option-file').on('click', selectFile);\n//\n//        //init image drag and drop\n//        if (typeof (FileReader) !== 'undefined') {\n//            window.addEventListener('dragover', function (event) {\n//                event.preventDefault();\n//                event.stopPropagation();\n//            }, false);\n//\n//            window.addEventListener('dragenter', function (event) {\n//                $('#drop-target-holder').show();\n//                event.preventDefault();\n//                event.stopPropagation();\n//            }, false);\n//\n//            window.addEventListener('drop', onFileDrop, false);\n//        }\n//\n//        videoIn.loop = true;\n//        videoIn.autoplay = true;\n//        videoIn.muted = true;\n//\n//        // safari only shows video texture if video is actually visible on screen??\n//        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n//        if (isSafari){\n//            console.log('IS SAFARI')\n//            document.body.appendChild(videoIn);\n//            videoIn.style.position = 'absolute';\n//            videoIn.style.height = '1px';\n//            videoIn.style.width = '1px';\n//        }\n//\n//    }\n//\n//    function selectFile() {\n//\n//        $('#file1').on('change', handleFileSelect, false);\n//\n//        if (MOSH.Main.getIsMobile()){\n//            //no drag prompt for mobile\n//            $('#file1').click();\n//        }else{\n//\n//            //$('#drop-prompt').show();\n//            $('#input-options').css('display', 'none');\n//            $('#cam-prompt').css('display', 'none');\n//            TweenMax.to($('#file-prompt'), 0.6, { autoAlpha: 1 });\n//\n//            $('#option-choose').on('click', function () {\n//                $('#file1').click();\n//            });\n//        }\n//    }\n//\n//    function handleFileSelect() {\n//\n//        var reader = new FileReader();\n//        reader.onload = function () {\n//            onImageLoaded(reader.result);\n//        };\n//        reader.readAsDataURL(this.files[0]);\n//    }\n//\n//    function onFileDrop(event) {\n//\n//        event.preventDefault();\n//        var file = event.dataTransfer.files[0];\n//        var fileType = file.type;\n//\n//        //determine if file is img or video\n//        //only accept img + video\n//        var reader = new FileReader();\n//        if (fileType.match(/image\\/\\w+/)) {\n//            reader.onload = function () {\n//                onImageLoaded(reader.result);\n//            };\n//        } else if (fileType.match(/video\\/\\w+/)) {\n//            reader.onload = function () {\n//                onVideoLoaded(reader.result);\n//            };\n//\n//        } else {\n//            console.alert('Only image and video files supported.');\n//            return;\n//        }\n//        reader.readAsDataURL(file);\n//    }\n//\n//    function onImageLoaded(path) {\n//\n//        //unload prev video\n//        videoIn.pause();\n//        videoIn.src = ''; // empty source\n//        videoIn.load();\n//\n//        var txtLdr = new THREE.TextureLoader();\n//        inputTexture = txtLdr.load(path, onImageLoaded2);\n//    }\n//\n//    function onImageLoaded2() {\n//        inputTexture.minFilter = THREE.LinearFilter;\n//        sourceSize = new THREE.Vector2(inputTexture.image.width, inputTexture.image.height);\n//        MOSH.Recorder.setInputDuration(0);\n//        onSourceReady();\n//    }\n//\n//    function onVideoLoaded(path) {\n//\n//        sourceReady = false;\n//        videoIn.onloadedmetadata = onVideoMetaDataLoaded;\n//        videoIn.src = path;\n//        videoIn.load(); // must call after setting/changing source\n//    }\n//\n//    function onCamReady(stream) {\n//        //console.log('onCamReady', stream)\n//        //on webcam enabled\n//        videoIn.onloadedmetadata = onCamMetaDataLoaded;\n//        videoIn.srcObject = stream;\n//    }\n//\n//    function onCamMetaDataLoaded(){\n//        onVideoMetaDataLoaded();\n//        MOSH.Recorder.setInputDuration(0);\n//    }\n//\n//    function onVideoMetaDataLoaded() {\n//\n//        //video dimensions avaiable\n//        //init video texture\n//        inputTexture = new THREE.VideoTexture(videoIn);\n//        inputTexture.minFilter = THREE.LinearFilter;\n//        sourceSize = new THREE.Vector2(videoIn.videoWidth, videoIn.videoHeight);\n//        onSourceReady();\n//\n//        //console.log('webcam dims:' , videoIn.videoWidth,videoIn.videoHeight);\n//\n//        //match recorder duration to input duration\n//        MOSH.Recorder.setInputDuration(videoIn.duration);\n//\n//\n//    }\n//\n//    function onSourceReady() {\n//\n//        //update UI for image loaded\n//        $('#webgl').css('display', 'block');\n//        $('#intro').css('display', 'none');\n//        $('#save-options').css('display', 'block');\n//        $('#controls-holder').css('display', 'block');\n//        $('#bottom-controls-holder').css('display', 'block');\n//        $('#top-arras').css('display', 'none');\n//        $('#drop-target-holder').hide();\n//\n//        sourceReady = true;\n//        MOSH.Main.updateMaterial(inputTexture);\n//    }\n//\n//    function selectCam() {\n//\n//        $('#input-options').css('display', 'none');\n//        $('#file-prompt').css('display', 'none');\n//        TweenMax.to($('#cam-prompt'), 0.6, { autoAlpha: 1 });\n//\n//        if (!hasGetUserMedia()) {\n//            $('#cam-prompt').html('WebCam access is not supported in this browser.<br>Please try using Chrome, Firefox or Opera');\n//            return;\n//        }\n//\n//        TweenMax.to($('#top-arras'), 0.6, { autoAlpha: 0.8 });\n//\n//        //Use webcam\n//        //request 1280x720\n//        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n//        //get webcam\n//        navigator.getUserMedia({\n//            video: {width: {exact: 1280}, height: {exact: 720}}\n//        }, onCamReady,\n//            function (error) {\n//                $('#cam-prompt').html('Unable to capture WebCam.<br>Please reload the page.');\n//            });\n//    }\n//\n//    function hasGetUserMedia() {\n//        return !!(navigator.getUserMedia || navigator.webkitGetUserMedia ||\n//            navigator.mozGetUserMedia || navigator.msGetUserMedia);\n//    }\n//\n//    return {\n//        init: init,\n//        getSourceReady: function(){ return sourceReady;},\n//        getSourceSize: function(){ return sourceSize;}\n//    };\n//\n//}();\n///*\n//    Mosh Recorder\n//    File saving\n//*/\n//\n///* global Events, ImprovedNoise , $ , THREE , TweenMax , Stats, MOSH , GIF , Power0 */\n//\n//MOSH.Recorder = function(){\n//\n//    var recordMode = 'jpg'; // jpg , gif, webm\n//    var recordTimer;\n//    var MAX_DURATION = 16;\n//    var videoDuration = MAX_DURATION; //seconds\n//\n//    var mediaRecorder, recordedBlobs;\n//\n//    var gif;\n//    var gifFPS = 20;\n//    var gifFrameTime = Math.floor(1000 / gifFPS);\n//    var gifInterval;\n//\n//    function init(){\n//        $('#opt-jpg').on('click', setJpgMode);\n//        $('#opt-gif').on('click', setGifMode);\n//        $('#opt-webm').on('click', setWebmMode);\n//        $('#btn-record').on('click', onRecordClick);\n//    }\n//\n//    function setJpgMode(){\n//        recordMode = 'jpg';\n//        $('#opt-jpg').addClass('selected');\n//        $('#opt-gif').removeClass('selected');\n//        $('#opt-webm').removeClass('selected');\n//        $('#btn-record').text('Save');\n//        $('#btn-record').removeClass('vid-mode');\n//        MOSH.Main.onResize();\n//    }\n//\n//    function setGifMode(){\n//        recordMode = 'gif';\n//        $('#opt-jpg').removeClass('selected');\n//        $('#opt-gif').addClass('selected');\n//        $('#opt-webm').removeClass('selected');\n//        $('#btn-record').text('Record');\n//        $('#btn-record').addClass('vid-mode');\n//        MOSH.Main.onResize();\n//    }\n//\n//    function setWebmMode(){\n//        recordMode = 'webm';\n//        $('#opt-jpg').removeClass('selected');\n//        $('#opt-gif').removeClass('selected');\n//        $('#opt-webm').addClass('selected');\n//        $('#btn-record').text('Record');\n//        $('#btn-record').addClass('vid-mode');\n//        MOSH.Main.onResize();\n//    }\n//\n//    function onRecordClick() {\n//\n//        if (recordMode === 'gif') {\n//            onRecordGif();\n//        } else if (recordMode === 'webm') {\n//            onRecordWebm();\n//        } else {\n//            saveImage();\n//        }\n//    }\n//\n//    function getFileName(){\n//        var now = new Date();\n//        return 'MOSHED-' + now.getFullYear() + '-' + (now.getMonth() + 1) + '-' + now.getDate() + '-' + now.getHours() + '-' + now.getMinutes() + '-' + now.getSeconds();\n//    }\n//\n//    //JPEG -------------------------------\n//\n//    function saveImage(){\n//\n//        MOSH.FX.getComposer().render(0.1);\n//        var imgData = MOSH.Main.getRenderer().domElement.toDataURL('image/jpeg');\n//\n//        if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {\n//            var a = document.createElement('a');\n//            a.href = imgData;\n//            a.download =  getFileName() + '.jpg';\n//            a.click();\n//        } else {\n//            window.open(imgData);\n//        }\n//    }\n//\n//\n//    // VIDEO COMMON\n//    function startRecording(){\n//\n//        //console.log('startRecording')\n//\n//        //disable record btn\n//        $('#btn-record').off('click',onRecordClick);\n//        $('#btn-record').css('cursor','default');\n//        $('#btn-record').toggleClass('recording');\n//        $('#btn-record').text('Recording...' );\n//\n//        $('#progress-bar').show();\n//        $('#progress-bar-bkgnd').show();\n//        TweenMax.fromTo($('#progress-bar'), videoDuration, {scaleX: 0},{scaleX: 1, ease: Power0.easeNone});\n//\n//        //pulsate record button\n//        TweenMax.fromTo($('#btn-record'),0.4,{backgroundColor:'rgba(255,0,0,0.15)'},{backgroundColor:'rgba(255,0,0,0.45)',yoyo:true,repeat:-1});\n//\n//        //stop after 4 seconds\n//        recordTimer = setTimeout(stopRecording, 73000);\n//\n//    }\n//\n//    function stopRecording(){\n//\n//        //console.log('stopRecording')\n//\n//        if (recordMode === 'gif') {\n//            onGifRecordEnd();\n//        } else if (recordMode === 'webm') {\n//            onWebmRecordEnd();\n//        }\n//\n//        $('#progress-bar').hide();\n//        $('#progress-bar-bkgnd').hide();\n//    }\n//\n//    function enableRecordButton(){\n//\n//        //renable button\n//        TweenMax.killTweensOf('#btn-record');\n//        TweenMax.set('#btn-record', { backgroundColor: 'rgba(255,255,255,0.15)' });\n//        $('#btn-record').on('click', onRecordClick);\n//        $('#btn-record').css('cursor', 'pointer');\n//        $('#btn-record').toggleClass('recording');\n//        $('#btn-record').text('Record' );\n//\n//    }\n//\n//    //GIF -------------------------------\n//\n//    function onRecordGif() {\n//\n//        //console.log('onRecordGif')\n//\n//        gif = new GIF({\n//            workers: 8,\n//            quality: 20,\n//            workerScript: 'js/workers/gif.worker.js',\n//        });\n//        gifInterval = setInterval(saveGifFrame, gifFrameTime);\n//        startRecording();\n//    }\n//\n//    function saveGifFrame(){\n//        // add a image element\n//        gif.addFrame(MOSH.Main.getRenderer().domElement, {copy: true, delay: gifFrameTime});\n//    }\n//\n//    function onGifRecordEnd() {\n//\n//        clearInterval(gifInterval);\n//        gif.render();\n//\n//        //console.log('onGifRecordEnd')\n//\n//        $('#btn-record').text('Processing...' );\n//\n//        gif.on('finished', function (blob) {\n//            downloadGif(blob);\n//        });\n//    }\n//\n//    function downloadGif(blob){\n//\n//        //console.log('downloadGif')\n//        if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n//            //firefox\n//            //console.log('recordingEnd FF');\n//            window.open(window.URL.createObjectURL(blob));\n//        } else {\n//            //other browsers\n//            var a = document.createElement('a');\n//            a.href = URL.createObjectURL(blob);\n//            //a.target = '_blank';\n//            a.download = getFileName() + '.gif';\n//            a.click();\n//        }\n//\n//        enableRecordButton();\n//    }\n//\n//\n//\n//    // WEBM -------------------------------\n//\n//    function onRecordWebm() {\n//\n//        //console.log('onRecordWebm')\n//\n//        var stream = MOSH.Main.getRenderer().domElement.captureStream(); // frames per second\n//        //console.log('Started stream capture from canvas element: ', stream);\n//\n//        //videoBitsPerSecond:\n//        //default: 2.5 Mbit/sec: 2500000\n//        //youtube reccomended for 1280x720: 7.5 Mbit/sec\n//\n//        var options = { mimeType: 'video/webm;codecs=H264' , videoBitsPerSecond :  10000000}; //10mb\n//\n//        recordedBlobs = [];\n//        try {\n//            mediaRecorder = new MediaRecorder(stream, options);\n//        } catch (e0) {\n//            console.log('Unable to create MediaRecorder with options Object: ', e0);\n//            try {\n//                options = { mimeType: 'video/webm,codecs=vp9' };\n//                mediaRecorder = new MediaRecorder(stream, options);\n//            } catch (e1) {\n//                console.log('Unable to create MediaRecorder with options Object: ', e1);\n//                try {\n//                    options = 'video/vp8'; // Chrome 47\n//                    mediaRecorder = new MediaRecorder(stream, options);\n//                } catch (e2) {\n//                    alert('MediaRecorder is not supported by this browser.\\n\\n' +\n//                        'Try Firefox 29 or later, or Chrome 47 or later, with Enable experimental Web Platform features enabled from chrome://flags.');\n//                    console.error('Exception while creating MediaRecorder:', e2);\n//                    return;\n//                }\n//            }\n//        }\n//        //console.log('Created MediaRecorder', mediaRecorder, 'with options', options);\n//        // recordButton.textContent = 'Stop Recording';\n//        // playButton.disabled = true;\n//        // downloadButton.disabled = true;\n//        //mediaRecorder.onstop = handleStop;\n//        mediaRecorder.ondataavailable = saveWebmFrame;\n//        mediaRecorder.start(100); // collect 100ms of data\n//        //console.log('MediaRecorder started', mediaRecorder);\n//\n//        startRecording();\n//    }\n//\n//    function saveWebmFrame(event) {\n//        if (event.data && event.data.size > 0) {\n//            recordedBlobs.push(event.data);\n//        }\n//    }\n//\n//    function onWebmRecordEnd() {\n//        mediaRecorder.stop();\n//        //console.log('Recorded Blobs: ', recordedBlobs);\n//        downloadVid();\n//        enableRecordButton();\n//    }\n//\n//    function downloadVid() {\n//\n//        var blob = new Blob(recordedBlobs, { type: 'video/webm' });\n//        var url = window.URL.createObjectURL(blob);\n//        var a = document.createElement('a');\n//        a.style.display = 'none';\n//        a.href = url;\n//        a.download = getFileName() + '.webm';\n//        document.body.appendChild(a);\n//        a.click();\n//        setTimeout(function () {\n//            document.body.removeChild(a);\n//            window.URL.revokeObjectURL(url);\n//        }, 100);\n//    }\n//\n//    function setInputDuration(t){\n//        //console.log('setInputDuration', t)\n//        //match input video duration capped to maximum duration\n////        videoDuration = Math.min(t, MAX_DURATION);\n//        //use max duration for image and webcam\n////        if (t === 0) videoDuration = MAX_DURATION;\n//        videoDuration = MAX_DURATION;\n//        console.log('videoDuration', videoDuration)\n//    }\n//\n//    return {\n//        init: init,\n//        setInputDuration: setInputDuration,\n//        getRecordMode: function(){return recordMode;},\n//        getVideoDuration: function() { return videoDuration;},\n//    };\n//\n//}();\n//\n///**\n// * @author felixturner / http://airtight.cc/\n// *\n// * Bad TV Shader\n// * Simulates a bad TV via horizontal distortion and vertical roll\n// * Uses Ashima WebGl Noise: https://github.com/ashima/webgl-noise\n// *\n// * time: steadily increasing float passed in\n// * distortion: amount of thick distortion\n// * distortion2: amount of fine grain distortion\n// * speed: distortion vertical travel speed\n// * rollSpeed: vertical roll speed\n// *\n// * v0.2\n// * Fixed black bars on mobile\n// */\n//\n//THREE.BadTVShader = {\n//    uniforms: {\n//        'tDiffuse': { type: 't', value: null },\n//        'time':     { type: 'f', value: 0.0 },\n//        'distortion':     { type: 'f', value: 3.0 },\n//        'distortion2':     { type: 'f', value: 5.0 },\n//        'speed':     { type: 'f', value: 0.116 },\n//        'rollSpeed':     { type: 'f', value: 0.05 },\n//    },\n//\n//    vertexShader: [\n//        'varying vec2 vUv;',\n//        'void main() {',\n//        'vUv = uv;',\n//        'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n//        '}'\n//\n//    ].join('\\n'),\n//\n//    fragmentShader: [\n//\n//        'uniform sampler2D tDiffuse;',\n//        'uniform float time;',\n//        'uniform float distortion;',\n//        'uniform float distortion2;',\n//        'uniform float speed;',\n//        'uniform float rollSpeed;',\n//        'varying vec2 vUv;',\n//\n//        // Start Ashima 2D Simplex Noise\n//\n//        'vec3 mod289(vec3 x) {',\n//        '  return x - floor(x * (1.0 / 289.0)) * 289.0;',\n//        '}',\n//\n//        'vec2 mod289(vec2 x) {',\n//        '  return x - floor(x * (1.0 / 289.0)) * 289.0;',\n//        '}',\n//\n//        'vec3 permute(vec3 x) {',\n//        '  return mod289(((x*34.0)+1.0)*x);',\n//        '}',\n//\n//        'float snoise(vec2 v)',\n//        '  {',\n//        '  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0',\n//        '                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)',\n//        '                     -0.577350269189626,  // -1.0 + 2.0 * C.x',\n//        '                      0.024390243902439); // 1.0 / 41.0',\n//        '  vec2 i  = floor(v + dot(v, C.yy) );',\n//        '  vec2 x0 = v -   i + dot(i, C.xx);',\n//\n//        '  vec2 i1;',\n//        '  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);',\n//        '  vec4 x12 = x0.xyxy + C.xxzz;',\n//        ' x12.xy -= i1;',\n//\n//        '  i = mod289(i); // Avoid truncation effects in permutation',\n//        '  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))',\n//        '\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));',\n//\n//        '  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);',\n//        '  m = m*m ;',\n//        '  m = m*m ;',\n//\n//        '  vec3 x = 2.0 * fract(p * C.www) - 1.0;',\n//        '  vec3 h = abs(x) - 0.5;',\n//        '  vec3 ox = floor(x + 0.5);',\n//        '  vec3 a0 = x - ox;',\n//\n//        '  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );',\n//\n//        '  vec3 g;',\n//        '  g.x  = a0.x  * x0.x  + h.x  * x0.y;',\n//        '  g.yz = a0.yz * x12.xz + h.yz * x12.yw;',\n//        '  return 130.0 * dot(m, g);',\n//        '}',\n//\n//        // End Ashima 2D Simplex Noise\n//\n//        'void main() {',\n//\n//            'vec2 p = vUv;',\n//            'float ty = time * speed * 17.346;',\n//            'float yt = p.y - ty;',\n//\n//            //thick distortion\n//            'float offset = snoise(vec2(yt*3.0,0.0))*0.2;',\n//            'offset = offset*distortion * offset*distortion * offset;',\n//            //fine distortion\n//            'offset += snoise(vec2(yt*50.0,0.0))*distortion2*0.002;',\n//\n//            //combine distortion on X with roll on Y\n//            'gl_FragColor = texture2D(tDiffuse,  vec2(fract(p.x + offset),fract(p.y - time * rollSpeed) ));',\n//\n//        '}'\n//\n//    ].join('\\n')\n//\n//};\n//\n///**\n// * @author felixturner / http://airtight.cc/\n// *\n// * Barrel Blur Chroma Distortion\n// *\n// * Ported from https://www.shadertoy.com/view/XssGz8\n// * by http://loopit.dk / @pixelmager\n// */\n//\n//THREE.BarrelBlurShader = {\n//\n//    uniforms: {\n//\n//        \"tDiffuse\": { type: \"t\", value: null },\n//        \"amount\":     { type: \"f\", value: 0.5 },\n//        \"time\":     { type: \"f\", value: 0.0 },\n//\n//    },\n//\n//    vertexShader: [\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//            \"vUv = uv;\",\n//            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n//\n//        \"}\"\n//\n//    ].join(\"\\n\"),\n//\n//    fragmentShader: [\n//\n//        \"uniform sampler2D tDiffuse;\",\n//        \"uniform float amount;\",\n//        \"uniform float time;\",\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"const int num_iter = 16;\",\n//        \"const float reci_num_iter_f = 1.0 / float(num_iter);\",\n//        \"const float gamma = 2.2;\",\n//        \"const float MAX_DIST_PX = 200.0;\",\n//\n//        \"vec2 barrelDistortion( vec2 p, vec2 amt )\",\n//        \"{\",\n//        \"    p = 2.0*p-1.0;\",\n//        \"    //float BarrelPower = 1.125;\",\n//        \"    const float maxBarrelPower = 3.0;\",\n//        \"    float theta  = atan(p.y, p.x);\",\n//        \"    float radius = length(p);\",\n//        \"    radius = pow(radius, 1.0 + maxBarrelPower * amt.x);\",\n//        \"    p.x = radius * cos(theta);\",\n//        \"    p.y = radius * sin(theta);\",\n//        \"    return 0.5 * ( p + 1.0 );\",\n//        \"}\",\n//\n//        \"float sat( float t )\",\n//        \"{\",\n//        \"\treturn clamp( t, 0.0, 1.0 );\",\n//        \"}\",\n//\n//        \"float linterp( float t ) {\",\n//        \"\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\",\n//        \"}\",\n//\n//        \"float remap( float t, float a, float b ) {\",\n//        \"\treturn sat( (t - a) / (b - a) );\",\n//        \"}\",\n//\n//        \"vec3 spectrum_offset( float t ) {\",\n//        \"\tvec3 ret;\",\n//        \"\tfloat lo = step(t,0.5);\",\n//        \"\tfloat hi = 1.0-lo;\",\n//        \"\tfloat w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\",\n//        \"\tret = vec3(lo,1.0,hi) * vec3(1.0-w, w, 1.0-w);\",\n//        \"\",\n//        \"\treturn pow( ret, vec3(1.0/2.2) );\",\n//        \"}\",\n//\n//        \"float nrand( vec2 n )\",\n//        \"{\",\n//        \"\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\",\n//        \"}\",\n//\n//        \"vec3 lin2srgb( vec3 c )\",\n//        \"{\",\n//        \"    return pow( c, vec3(gamma) );\",\n//        \"}\",\n//\n//        \"vec3 srgb2lin( vec3 c )\",\n//        \"{\",\n//        \"    return pow( c, vec3(1.0/gamma));\",\n//        \"}\",\n//\n//        \"void main() {\",\n//\n//            \"vec2 uv = vUv;\",\n//            \"vec2 max_distort = vec2(amount);\", //resolution independent\n//\n//            \"vec2 oversiz = barrelDistortion( vec2(1,1), max_distort );\",\n//            \"uv = 2.0 * uv - 1.0;\",\n//            \"uv = uv / (oversiz*oversiz);\",\n//            \"uv = 0.5 * uv + 0.5;\",\n//\n//            \"vec3 sumcol = vec3(0.0);\",\n//            \"vec3 sumw = vec3(0.0);\",\n//            \"float rnd = nrand( uv + fract(time) );\",\n//            \"for ( int i=0; i<num_iter;++i ){\",\n//                \"float t = (float(i)+rnd) * reci_num_iter_f;\",\n//                \"vec3 w = spectrum_offset( t );\",\n//                \"sumw += w;\",\n//                \"sumcol += w * srgb2lin(texture2D( tDiffuse, barrelDistortion(uv, max_distort*t ) ).rgb);\",\n//            \"}\",\n//\n//            \"sumcol.rgb /= sumw;\",\n//            \"vec3 outcol = lin2srgb(sumcol.rgb);\",\n//            \"outcol += rnd/255.0;\",\n//            \"gl_FragColor = vec4( outcol, 1.0);\",\n//\n//\n//\n//        \"}\"\n//\n//    ].join(\"\\n\")\n//\n//};\n//\n///**\n// * @author felixturner / http://airtight.cc/\n// *\n// * Renders texture as a grid of dots\n// *\n// * dots: number of dots on x + y axis\n// * size: size of dot within dot area 0-1\n// * blur: size of blur within dot area 0-1\n// */\n//\n// THREE.DotMatrixShader = {\n//\n//    uniforms: {\n//\n//        \"tDiffuse\": { type: \"t\", value: null },\n//        \"dots\":  { type: \"f\", value: 40.0 }, //size of dot area as fraction of screen\n//        \"size\":     { type: \"f\", value: 0.3 }, //0-1 size of dot within dot area\n//        \"blur\":     { type: \"f\", value: 0.3 } //size of blur within dot area\n//\n//    },\n//\n//    vertexShader: [\n//\n//    \"varying vec2 vUv;\",\n//\n//    \"void main() {\",\n//\n//        \"vUv = uv;\",\n//        \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n//\n//    \"}\"\n//\n//    ].join(\"\\n\"),\n//\n//    fragmentShader: [\n//\n//        \"uniform sampler2D tDiffuse;\",\n//        \"uniform float dots;\",\n//        \"uniform float size;\",\n//        \"uniform float blur;\",\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//            \"float dotSize = 1.0/dots;\",\n//            \"vec2 samplePos = vUv - mod(vUv, dotSize) + 0.5 * dotSize;\",\n//            \"float distanceFromSamplePoint = distance(samplePos, vUv);\",\n//            \"vec4 col = texture2D(tDiffuse, samplePos);\",\n//            \"gl_FragColor = mix(col, vec4(0.0), smoothstep(dotSize * size, dotSize *(size + blur), distanceFromSamplePoint));\",\n//\n//        \"}\"\n//\n//        ].join(\"\\n\")\n//\n//    };\n//\n///**\n//\n//    DuoToneShader\n//\n//    Map luminace to a color gradient\n//\n//        colLight:\n//        colDark:\n//        brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)\n//        contrast: 0-1 (0 is no change, 1 is maximum contrast)\n//\n//    @author felixturner / http://airtight.cc/\n//\n//\n// */\n//\n//THREE.DuoToneShader = {\n//\n//    uniforms: {\n//\n//        'tDiffuse': \t{ value: null },\n//        'colLight':    \t{ value: new THREE.Color(0.953 , 0.173 , 0.36) },\n//        'colDark':   \t{ value: new THREE.Color(0.180 , 0.184 , 0.380) },\n//        // 'brightness':   { value: 0.0 },\n//        // 'contrast':    \t{ value: 0.0}\n//\n//    },\n//\n//    vertexShader: [\n//\n//        'varying vec2 vUv;',\n//\n//        'void main() {',\n//\n//            'vUv = uv;',\n//            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n//\n//        '}'\n//\n//    ].join( '\\n' ),\n//\n//    fragmentShader: [\n//\n//        'uniform sampler2D tDiffuse;',\n//        'uniform vec3 colLight;',\n//        'uniform vec3 colDark;',\n//        //'uniform float brightness;',\n//        //'uniform float contrast;',\n//\n//        'varying vec2 vUv;',\n//\n//        //get float luma from color\n//        'float luma(vec3 color) {',\n//            'return dot(color, vec3(0.299, 0.587, 0.114));',\n//        '}',\n//\n//        //boost contrast\n//        'vec3 boostContrast(vec3 col, float amount){',\n//            'return  (col - 0.5) / (1.0 - amount) + 0.5;',\n//        '}',\n//\n//        'void main() {',\n//\n//            'vec3 col =  texture2D(tDiffuse, vUv).rgb;',\n//            //'col += brightness;',\n//            //'col = boostContrast(col,contrast);',\n//            'col = clamp(col,0.0,1.0);',\n//            'col = mix(colDark,colLight, luma(col));',\n//            'gl_FragColor = vec4(col,1.0);',\n//\n//        '}'\n//\n//    ].join( '\\n' )\n//\n//};\n//\n///**\n//\n//    Modified version of THREE.EdgeShader2\n//    added passthru fixed console error\n//    modified by @felixturner\n//\n// */\n//\n//THREE.EdgeShader = {\n//\n//    uniforms: {\n//\n//        'tDiffuse': { value: null },\n//        'amount':   { value: 0 },\n//        'passthru':   { value: 0 },\n//    },\n//\n//    vertexShader: [\n//\n//        'varying vec2 vUv;',\n//\n//        'void main() {',\n//\n//            'vUv = uv;',\n//            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n//\n//        '}'\n//\n//    ].join( '\\n' ),\n//\n//    fragmentShader: [\n//\n//        'uniform sampler2D tDiffuse;',\n//        'uniform float amount;',\n//        'uniform float passthru;',\n//        'varying vec2 vUv;',\n//\n//        'vec2 texel = vec2(1.0 /512.0);',\n//\n//        'mat3 G[2];',\n//\n//        'const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );',\n//        'const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );',\n//\n//\n//        'void main(void)',\n//        '{',\n//            'mat3 I;',\n//            'float cnv[2];',\n//            'vec3 sample;',\n//\n//            'G[0] = g0;',\n//            'G[1] = g1;',\n//\n//            /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n//            'for (float i=0.0; i<3.0; i++)',\n//            'for (float j=0.0; j<3.0; j++) {',\n//                'sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;',\n//                'I[int(i)][int(j)] = length(sample);',\n//            '}',\n//\n//            /* calculate the convolution values for all the masks */\n//            'for (int i=0; i<2; i++) {',\n//                'float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);',\n//                'cnv[i] = dp3 * dp3; ',\n//            '}',\n//\n//            'vec4 orig = texture2D( tDiffuse, vUv);',\n//\n//            'gl_FragColor = orig * passthru + vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1])) * amount;',\n//        '} ',\n//\n//    ].join( '\\n' )\n//\n//};\n//\n///**\n// * @author felixturner / http://airtight.cc/\n// *\n// * Glitcher Shader\n// * webgl version of ImageGlitcher: https://www.airtightinteractive.com/demos/js/imageglitcher/\n// */\n//\n//THREE.GlitcherShader = {\n//\n//    uniforms: {\n//\n//        \"tDiffuse\": { type: \"t\", value: null },\n//        \"amount\":     { type: \"f\", value: 0.5 }, //0-1\n//        \"speed\":     { type: \"f\", value: 0.5 },  //0-1\n//        \"time\":     { type: \"f\", value: 0 },  //ms\n//\n//    },\n//\n//    vertexShader: [\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//            \"vUv = uv;\",\n//            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n//\n//        \"}\"\n//\n//    ].join(\"\\n\"),\n//\n//    fragmentShader: [\n//\n//        \"uniform sampler2D tDiffuse;\",\n//        \"varying vec2 vUv;\",\n//        \"uniform float amount;\",\n//        \"uniform float speed;\",\n//        \"uniform float time;\",\n//\n//        \"float random1d(float n){\",\n//            \"return fract(sin(n) * 43758.5453);\",\n//        \"}\",\n//\n//        //2D (returns 0 - 1)\n//        \"float random2d(vec2 n) { \",\n//            \"return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\",\n//        \"}\",\n//\n//        \"float randomRange (in vec2 seed, in float min, in float max) {\",\n//            \"return min + random2d(seed) * (max - min);\",\n//        \"}\",\n//\n//        // return 1 if v inside 1d range\n//        \"float insideRange(float v, float bottom, float top) {\",\n//        \"return step(bottom, v) - step(top, v);\",\n//        \"}\",\n//\n//        \"float rand(vec2 co){\",\n//            \"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\",\n//        \"}\",\n//\n//        \"void main() {\",\n//\n//            \"vec2 uv = vUv;\",\n//\n//            \"float sTime = floor(time * speed * 6.0 * 24.0);\",\n//            \"vec3 inCol = texture2D(tDiffuse, uv).rgb;\",\n//\n//            //copy orig\n//            \"vec3 outCol = inCol;\",\n//\n//            //randomly offset slices horizontally\n//            \"float maxOffset = amount/2.0;\",\n//\n//            \"vec2 uvOff;\",\n//\n//            \"for (float i = 0.0; i < 10.0; i += 1.0) {\",\n//\n//                \"if (i > 10.0 * amount) break;\",\n//\n//                \"float sliceY = random2d(vec2(sTime + amount, 2345.0 + float(i)));\",\n//                \"float sliceH = random2d(vec2(sTime + amount, 9035.0 + float(i))) * 0.25;\",\n//                \"float hOffset = randomRange(vec2(sTime + amount, 9625.0 + float(i)), -maxOffset, maxOffset);\",\n//                \"uvOff = uv;\",\n//                \"uvOff.x += hOffset;\",\n//                \"vec2 uvOff = fract(uvOff);\",\n//                \"if (insideRange(uv.y, sliceY, fract(sliceY+sliceH)) == 1.0 ){\",\n//                    \"outCol = texture2D(tDiffuse, uvOff).rgb;\",\n//                \"}\",\n//            \"}\",\n//\n//            //do color offset - slight shift on one enr=tire channel\n//            \"float maxColOffset = amount/6.0;\",\n//            \"vec2 colOffset = vec2(randomRange(vec2(sTime + amount, 3545.0),-maxColOffset,maxColOffset), randomRange(vec2(sTime , 7205.0),-maxColOffset,maxColOffset));\",\n//\n//            \"uvOff = fract(uv + colOffset);\",\n//\n//            //TODO - use col[1] array access\n//            \"float rnd = random2d(vec2(sTime + amount, 9545.0));\",\n//            \"if (rnd < 0.33){\",\n//                \"outCol.r = texture2D(tDiffuse, uvOff).r;\",\n//            \"}else if (rnd < 0.66){\",\n//                \"outCol.g = texture2D(tDiffuse, uvOff).g;\",\n//            \"} else{\",\n//                \"outCol.b = texture2D(tDiffuse, uvOff).b;\",\n//            \"}\",\n//\n//            \"gl_FragColor = vec4(outCol,1.0);\",\n//        \"}\"\n//    ].join(\"\\n\")\n//\n//};\n//\n// /**\n// * Glow Shader\n// * Additively Blended Horizontal and Vertical Blur\n// *\n// * - darken orginal image before applying glow to only glow brighter areas\n// *\n// * amount - amount of glow to add.\n// * size - size of blur. Higher values will give visible chunkiness.\n// * resolution - renderer resolution in pixels (width, height). If you don't set it, nothing will break.\n// *\n// * @author felixturner / http://airtight.cc/\n// * Uses H + V Blur filter code by zz85 / http://www.lab4games.net/zz85/blog\n// *\n// */\n//\n//THREE.GlowShader = {\n//\n//    uniforms: {\n//\n//        \"tDiffuse\": \t{ type: \"t\", value: null },\n//        \"amount\":       { type: \"f\", value: 0.5 },\n//        \"size\":        \t{ type: \"f\", value: 4.0 },\n//        \"darkness\":     { type: \"f\", value: 0.1 },\n//        \"resolution\":   { type: \"v2\", value: new THREE.Vector2( 800.0, 600.0 )  }\n//\n//    },\n//\n//    vertexShader: [\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//            \"vUv = uv;\",\n//            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n//\n//        \"}\"\n//\n//    ].join(\"\\n\"),\n//\n//    fragmentShader: [\n//\n//        \"uniform sampler2D tDiffuse;\",\n//\n//        \"uniform float size;\",\n//        \"uniform float amount;\",\n//        \"uniform vec2 resolution;\",\n//        \"uniform float darkness;\",\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//            \"float h = size / resolution.x;\",\n//            \"float v = size / resolution.y;\",\n//\n//            \"vec4 sum = vec4( 0.0 );\",\n//\n//            //H Blur\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) )- darkness) * 0.051 ;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) )- darkness) * 0.0918;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) )- darkness) * 0.12245;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) )- darkness) * 0.1531;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x, vUv.y ) )- darkness) * 0.1633;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) )- darkness) * 0.1531;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) )- darkness) * 0.12245;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) )- darkness) * 0.0918;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) )- darkness) * 0.051;\",\n//\n//            //V Blur\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) )- darkness) * 0.051;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) )- darkness) * 0.0918;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) )- darkness) * 0.12245;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) )- darkness) * 0.1531;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x, vUv.y ) )- darkness) * 0.1633;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) )- darkness) * 0.1531;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) )- darkness) * 0.12245;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) )- darkness) * 0.0918;\",\n//            \"sum += (texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) )- darkness) * 0.051;\",\n//\n//            //get original pixel color\n//            \"vec4 base = texture2D( tDiffuse, vUv );\",\n//\n//            //Additive Blend\n//            \"gl_FragColor = base + max(sum,0.0) * amount;\",\n//\n//        \"}\"\n//\n//    ].join(\"\\n\")\n//\n//};\n//\n///**\n// * @author felixturner / http://airtight.cc/\n// *\n// * Pixelate Shader\n// * make into pixels\n// *\n// */\n//\n//THREE.LUTShader = {\n//\n//    uniforms: {\n//        \"tDiffuse\": { type: \"t\", value: null },\n//        \"lookupTable\": { type: \"t\", value: null },\n//        \"strength\":  { type: \"f\", value: 1.0 }\n//    },\n//\n//    vertexShader: [\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//            \"vUv = uv;\",\n//            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n//\n//        \"}\"\n//\n//    ].join(\"\\n\"),\n//\n//    fragmentShader: [\n//\n//        \"uniform sampler2D tDiffuse;\",\n//        \"uniform sampler2D lookupTable;\",\n//        \"uniform float strength;\",\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//            \"vec4 col = texture2D( tDiffuse, vUv );\",\n//            // \"gl_FragColor = mix(col,vec4(1.0,0.0,1.0,1.0),strength);\",\n//\n//            //CLAMP\n//            //\"col = clamp(col, 0.0, 1.0);\",\n//\n//\n//            \"float blueColor = col.b * 63.0;\",\n//\n//            \"vec2 quad1;\",\n//            \"quad1.y = floor(floor(blueColor) / 8.0);\",\n//            \"quad1.x = floor(blueColor) - (quad1.y * 8.0);\",\n//\n//            \"vec2 quad2;\",\n//            \"quad2.y = floor(ceil(blueColor) / 8.0);\",\n//            \"quad2.x = ceil(blueColor) - (quad2.y * 8.0);\",\n//\n//            \"vec2 texPos1;\",\n//            \"texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * col.r);\",\n//            \"texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * col.g);\",\n//\n//            //INVERT\n//            \"texPos1.y = 1.0-texPos1.y;\",\n//\n//            \"vec2 texPos2;\",\n//            \"texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * col.r);\",\n//            \"texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * col.g);\",\n//\n//            //INVERT\n//            \"texPos2.y = 1.0-texPos2.y;\",\n//\n//            \"vec4 newColor1 = texture2D(lookupTable, texPos1);\",\n//            \"vec4 newColor2 = texture2D(lookupTable, texPos2);\",\n//\n//            \"vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\",\n//\n//            //\"gl_FragColor.rgb = mix(col.rgb,newColor.rgb,strength);\",\n//            //\"gl_FragColor = mix(col,newColor,strength);\",\n//\n//            \"gl_FragColor = mix(col, vec4(newColor.rgb, col.w), strength);\",\n//            //\"gl_FragColor = newColor;\",\n//\n//\n//        \"}\"\n//\n//    ].join(\"\\n\")\n//\n//};\n//\n///**\n// *\n// * ported from https://www.clicktorelease.com/code/codevember-2016/22/\n// * @author felixturner / http://airtight.cc/\n// *\n// */\n//\n//THREE.LinocutShader = {\n//\n//    uniforms: {\n//        'tDiffuse': { type: 't', value: null },\n//        'resolution':     { type: 'v2'},\n//        'scale':     { type: 'f', value: 0.0 },\n//    },\n//\n//    vertexShader: [\n//\n//        'varying vec2 vUv;',\n//\n//        'void main() {',\n//\n//            'vUv = uv;',\n//            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n//\n//        '}'\n//\n//    ].join('\\n'),\n//\n//    fragmentShader: [\n//\n//        'uniform sampler2D tDiffuse;',\n//        'uniform vec2 resolution;',\n//        'varying vec2 vUv;',\n//        'uniform float scale;',\n//\n//        'float luma(vec3 color) {',\n//            'return dot(color, vec3(0.299, 0.587, 0.114));',\n//        '}',\n//\n//        'void main() {',\n//\n//            'vec2 center = vec2( 0.5 );',\n//            'vec2 uv = vUv;',\n//\n//            'float noiseScale = 1.;',\n//            'float radius = 0.5;',\n//            'vec2 d = uv - center;',\n//            'float r = length( d * vec2( 1., resolution.y / resolution.x ) ) * scale;',\n//            'float a = atan(d.y,d.x) + noiseScale*(radius-r)/radius;',\n//            'vec2 uvt = center+r*vec2(cos(a),sin(a));',\n//\n//            'vec2 uv2 = vUv;',\n//            'float c = ( .75 + .25 * sin( uvt.x * 1000. ) );',\n//            'vec4 color = texture2D( tDiffuse, uv2 );',\n//            'float l = luma( color.rgb );',\n//            'float f = smoothstep( .5 * c, c, l );',\n//            'f = smoothstep( 0., .5, f );',\n//\n//            'vec3 col = vec3(f);',\n//\n//            'gl_FragColor = vec4( col,.0);',\n//\n//        '}'\n//\n//    ].join('\\n')\n//\n//};\n//\n///**\n//\n//     Noise Displace Shader\n//\n//     A nice multi-octave noise pixel displacement.\n//\n//     @author Felix Turner / www.airtight.cc / @felixturner\n//\n//    Uses Ashima WebGL Noise: https://github.com/ashima/webgl-noise\n//\n//     The MIT License\n//\n//     Copyright (c) 2017 Felix Turner\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of\n//    this software and associated documentation files (the \"Software\"), to deal in\n//    the Software without restriction, including without limitation the rights to use,\n//    copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n//    Software, and to permit persons to whom the Software is furnished to do so, subject\n//    to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all\n//    copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n//    PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n//    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n//    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n//    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// */\n//\n//THREE.NoiseDisplaceShader = {\n//\n//    uniforms: {\n//\n//        'tDiffuse': { type: 't', value: null },\n//        'time': { type: 'f', value: 1.0 },\n//        'speed': { type: 'f', value: 0.5 },\n//        'scale': { type: 'f', value: 0.5 },\n//        'amount': { type: 'f', value: 0.5 },\n//    },\n//\n//    vertexShader: [\n//\n//        'varying vec2 vUv;',\n//\n//        'void main() {',\n//\n//            'vUv = uv;',\n//            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n//\n//        '}'\n//\n//    ].join('\\n'),\n//\n//    fragmentShader: [\n//\n//\n//        'uniform sampler2D tDiffuse;',\n//        'uniform float time;',\n//        'uniform float scale;',\n//        'uniform float amount;',\n//        'uniform float speed;',\n//        'varying vec2 vUv;',\n//\n//        // Start Ashima 2D Simplex Noise\n//\n//        'vec3 mod289(vec3 x) {',\n//        '  return x - floor(x * (1.0 / 289.0)) * 289.0;',\n//        '}',\n//\n//        'vec2 mod289(vec2 x) {',\n//        '  return x - floor(x * (1.0 / 289.0)) * 289.0;',\n//        '}',\n//\n//        'vec3 permute(vec3 x) {',\n//        '  return mod289(((x*34.0)+1.0)*x);',\n//        '}',\n//\n//        'float snoise(vec2 v)',\n//        '  {',\n//        '  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0',\n//        '                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)',\n//        '                     -0.577350269189626,  // -1.0 + 2.0 * C.x',\n//        '                      0.024390243902439); // 1.0 / 41.0',\n//        '  vec2 i  = floor(v + dot(v, C.yy) );',\n//        '  vec2 x0 = v -   i + dot(i, C.xx);',\n//\n//        '  vec2 i1;',\n//        '  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);',\n//        '  vec4 x12 = x0.xyxy + C.xxzz;',\n//        ' x12.xy -= i1;',\n//\n//        '  i = mod289(i); // Avoid truncation effects in permutation',\n//        '  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))',\n//        '\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));',\n//\n//        '  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);',\n//        '  m = m*m ;',\n//        '  m = m*m ;',\n//\n//        '  vec3 x = 2.0 * fract(p * C.www) - 1.0;',\n//        '  vec3 h = abs(x) - 0.5;',\n//        '  vec3 ox = floor(x + 0.5);',\n//        '  vec3 a0 = x - ox;',\n//\n//        '  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );',\n//\n//        '  vec3 g;',\n//        '  g.x  = a0.x  * x0.x  + h.x  * x0.y;',\n//        '  g.yz = a0.yz * x12.xz + h.yz * x12.yw;',\n//        '  return 130.0 * dot(m, g);',\n//        '}',\n//\n//        // End Ashima 2D Simplex Noise\n//\n//\n//        'float getNoise(vec2 uv, float t){',\n//\n//            //generate multi-octave noise based on uv position and time\n//            //move noise  over time\n//\n//            //scale noise position relative to center\n//            'uv -= 0.5;',\n//\n//            //octave 1\n//            'float scl = 4.0 * scale;',\n//            'float noise = snoise( vec2(uv.x * scl ,uv.y * scl - t * speed ));',\n//\n//            //octave 2\n//            'scl = 16.0 * scale;',\n//            'noise += snoise( vec2(uv.x * scl + t* speed ,uv.y * scl )) * 0.2 ;',\n//\n//            //octave 3\n//            'scl = 26.0 * scale;',\n//            'noise += snoise( vec2(uv.x * scl + t* speed ,uv.y * scl )) * 0.2 ;',\n//\n//            'return noise;',\n//\n//        '}',\n//\n//\n//        'void main() {',\n//\n//            'vec2 uv = vUv;',\n//\n//            'float noise = getNoise(uv, time * 24.0);',\n//            'vec2 noiseUv = uv + amount * noise;',\n//\n//            //wrap\n//            'noiseUv = fract(noiseUv);',\n//\n//            'gl_FragColor = texture2D(tDiffuse,noiseUv);',\n//\n//\n//        '}'\n//\n//    ].join('\\n')\n//\n//};\n//\n///**\n// * @author felixturner / http://airtight.cc/\n// *\n// * Pixelate Shader\n// * make into pixels\n// *\n// */\n//\n//THREE.PixelateShader = {\n//\n//    uniforms: {\n//\n//        \"tDiffuse\": { type: \"t\", value: null },\n//        \"pixelsX\":     { type: \"f\", value: 10 }, //number of pixels on x\n//        \"pixelsY\":     { type: \"f\", value: 10 } //number of pixels on  Y\n//\n//    },\n//\n//    vertexShader: [\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//            \"vUv = uv;\",\n//            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n//\n//        \"}\"\n//\n//    ].join(\"\\n\"),\n//\n//    fragmentShader: [\n//\n//        \"uniform sampler2D tDiffuse;\",\n//        \"uniform float pixelsX;\",\n//        \"uniform float pixelsY;\",\n//\n//        \"varying vec2 vUv;\",\n//\n//        // \"const float M_PI = 3.14159265358979323846;\",\n//\n//        // \"const mat2 rotation = mat2( cos(M_PI/4.0), sin(M_PI/4.0),\",\n//        //\t\t\t\t\t\t\"-sin(M_PI/4.0), cos(M_PI/4.0));\",\n//\n//        \"void main() {\",\n//\n//            //\"vec2 p = vUv * rotation;\",\n//            //roate (broken)\n//            //\"vec2 p = vUv * mat2(0.707, -0.707, 0.707, 0.707);\",\n//\n//\n//            \"vec2 p = vUv;\",\n//\n//            \"p.x = floor(p.x * pixelsX)/pixelsX + 0.5/pixelsX;\",\n//            \"p.y = floor(p.y * pixelsY)/pixelsY + 0.5/pixelsY;\",\n//\n//            \"gl_FragColor = texture2D(tDiffuse, p);\",\n//\n//        \"}\"\n//\n//    ].join(\"\\n\")\n//\n//};\n//\n///**\n// * @author felixturner / http://airtight.cc/\n// *\n// * Polar Pixelate Shader ported from GPUImage\n// *\n// */\n//\n//THREE.PolarPixelateShader = {\n//\n//    uniforms: {\n//\n//        \"tDiffuse\": { type: \"t\", value: null },\n//        \"pixelsX\":     { type: \"f\", value: 0.05 }, //number of pixels on x\n//        \"pixelsY\":     { type: \"f\", value: 0.05 } //number of pixels on  Y\n//\n//    },\n//\n//    vertexShader: [\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//            \"vUv = uv;\",\n//            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n//\n//        \"}\"\n//\n//    ].join(\"\\n\"),\n//\n//    fragmentShader: [\n//\n//        \"uniform sampler2D tDiffuse;\",\n//        \"uniform float pixelsX;\",\n//        \"uniform float pixelsY;\",\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//\n//            \"vec2 normCoord = 2.0 * vUv - 1.0;\",\n//            //\"vec2 normCenter = 2.0 * center - 1.0;\",\n//\n//            //\"normCoord -= normCenter;\",\n//\n//            \"float r = length(normCoord);\", // to polar coords\n//            \"float phi = atan(normCoord.y, normCoord.x);\", // to polar coords\n//\n//            \"r = r - mod(r, pixelsX) + 0.03;\",\n//            \"phi = phi - mod(phi, pixelsY);\",\n//\n//            \"normCoord.x = r * cos(phi);\",\n//            \"normCoord.y = r * sin(phi);\",\n//\n//           // \"normCoord += normCenter;\",\n//\n//            \"vec2 textureCoordinateToUse = normCoord / 2.0 + 0.5;\",\n//\n//            \"gl_FragColor = texture2D(tDiffuse, textureCoordinateToUse );\",\n//\n//\n//        \"}\"\n//\n//    ].join(\"\\n\")\n//\n//};\n//\n///**\n// * @author felixturner. ported from GPUImage\n// *\n// */\n//\n//THREE.PosterizeShader = {\n//\n//    uniforms: {\n//\n//        \"tDiffuse\":   { type: \"t\", value: null },\n//        \"levels\": { type: \"f\", value: 4.0 },\n//\n//    },\n//\n//    vertexShader: [\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//            \"vUv = uv;\",\n//\n//            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n//\n//        \"}\"\n//\n//    ].join(\"\\n\"),\n//\n//    fragmentShader: [\n//\n//        \"uniform sampler2D tDiffuse;\",\n//        \"uniform float levels;\",\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//            \"vec4 col = texture2D( tDiffuse, vUv );\",\n//            \"gl_FragColor.rgb = floor((col.rgb * levels) + vec3(0.5)) / levels;\",\n//        \"}\"\n//\n//    ].join(\"\\n\")\n//\n//};\n//\n///**\n//\n//    Rainbow shader\n//\n//    offset a rainbow gradient with rg channel\n//\n//    like: https://www.shadertoy.com/view/lljfzm\n//\n//    tDiffuse: \tbase texture\n//    flatten: amount to flatten into horiz stripes\n//    offset: color sample offset position\n//\n//    based on: https://www.airtightinteractive.com/demos/smear/\n//\n//    @author felixturner / http://airtight.cc/\n//\n// */\n//\n//THREE.RainbowShader = {\n//\n//    uniforms: {\n//\n//        'tDiffuse': { type: 't', value: null },\n//        'amount': { type: 'f', value: 0.5},\n//        'offset': { type: 'f', value: 0.5},\n//        'time': { type: 'f', value: 0.5},\n//\n//\n//    },\n//\n//    vertexShader: [\n//\n//        'varying vec2 vUv;',\n//        'void main() {',\n//\n//            'vUv = uv;',\n//            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n//\n//        '}'\n//\n//    ].join('\\n'),\n//\n//    fragmentShader: [\n//\n//        'uniform sampler2D tDiffuse;',\n//        'uniform float amount;',\n//        'uniform float offset;',\n//        'uniform float time;',\n//\n//        'varying vec2 vUv;',\n//\n//        'vec3 rainbow2( in float t ){',\n//            'vec3 d = vec3(0.0,0.33,0.67);',\n//            'return 0.5 + 0.5*cos( 6.28318*(t+d) );',\n//        '}',\n//\n//\n//        'void main() {',\n//\n//            'vec2 p = vUv;',\n//            'vec3 origCol = texture2D( tDiffuse, p ).rgb;',\n//\n//            'vec2 off = texture2D( tDiffuse, p ).rg - 0.5;',\n//            'p += off * offset;',\n//             'vec3 rb = rainbow2( (p.x + p.y + time * 2.0) * 0.5);',\n//\n//             'vec3 col = mix(origCol,rb,amount);',\n//\n//             'gl_FragColor = vec4(col, 1.0);',\n//\n//        '}'\n//\n//    ].join('\\n')\n//\n//};\n//\n///**\n//\n//    Simplified version of THREE.FilmShader\n//    Seperate out noise and lines\n//\n//\n// */\n//\n//THREE.ScanlinesShader = {\n//\n//    uniforms: {\n//\n//        \"tDiffuse\":   { value: null },\n//        \"time\":       { value: 0.0 },\n//        \"noiseAmount\": { value: 0.5 },\n//        \"linesAmount\": { value: 0.05 },\n//        \"count\":     { value: 4096 },\n//        \"height\":     { value: 4096 },\n//\n//    },\n//\n//    vertexShader: [\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"void main() {\",\n//\n//            \"vUv = uv;\",\n//            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n//\n//        \"}\"\n//\n//    ].join( \"\\n\" ),\n//\n//    fragmentShader: [\n//\n//        \"uniform sampler2D tDiffuse;\",\n//        \"uniform float time;\",\n//        \"uniform float count;\",\n//        \"uniform float noiseAmount;\",\n//        \"uniform float linesAmount;\",\n//        \"uniform float height;\",\n//\n//        \"varying vec2 vUv;\",\n//\n//        \"#define PI 3.14159265359\",\n//\n//        \"highp float rand( const in vec2 uv ) {\",\n//            \"const highp float a = 12.9898, b = 78.233, c = 43758.5453;\",\n//            \"highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\",\n//            \"return fract(sin(sn) * c);\",\n//        \"}\",\n//\n//        \"void main() {\",\n//\n//            // sample the source\n//            \"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n//\n//            // add noise\n//            \"float dx = rand( vUv + time );\",\n//            \"vec3 cResult = cTextureScreen.rgb * dx * noiseAmount;\",\n//\n//            // add scanlines\n//            'float lineAmount = height * 1.8 * count;',\n//            \"vec2 sc = vec2( sin( vUv.y * lineAmount), cos( vUv.y * lineAmount) );\",\n//            \"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * linesAmount;\",\n//\n//            // interpolate between source and result by intensity\n//            \"cResult = cTextureScreen.rgb + ( cResult );\",\n//\n//            \"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n//\n//        \"}\"\n//\n//    ].join( \"\\n\" )\n//\n//};\n//\n///**\n// * @author felixturner / http://airtight.cc/\n// *\n// * Slices Shader\n// * horizontal slices with random offsets\n// */\n//\n//THREE.SlicesShader = {\n//\n//    uniforms: {\n//\n//        'tDiffuse': { type: 't', value: null },\n//        'slices':     { type: 'f', value: 10 },\n//        'offset':     { type: 'f', value: 0.3 }, //max offset\n//        'speedH':     { type: 'f', value: 0.5 },\n//        'speedV':     { type: 'f', value: 1.0 },\n//        'time':     { type: 'f', value: 0.0 },\n//\n//    },\n//\n//    vertexShader: [\n//\n//        'varying vec2 vUv;',\n//\n//        'void main() {',\n//\n//            'vUv = uv;',\n//            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n//\n//        '}'\n//\n//    ].join('\\n'),\n//\n//    fragmentShader: [\n//\n//        'uniform sampler2D tDiffuse;',\n//        'uniform float slices;',\n//        'uniform float offset;',\n//        'uniform float time;',\n//        'uniform float speedV;',\n//        'uniform float speedH;',\n//        'varying vec2 vUv;',\n//\n//        'float steppedVal(float v, float steps){',\n//            'return floor(v*steps)/steps;',\n//        '}',\n//\n//        //RANDOM\n//        //1D\n//        //returns 0 - 1\n//        'float random1d(float n){',\n//            'return fract(sin(n) * 43758.5453);',\n//        '}',\n//\n//        //returns 0 - 1\n//        'float noise1d(float p){',\n//            'float fl = floor(p);',\n//            'float fc = fract(p);',\n//            'return mix(random1d(fl), random1d(fl + 1.0), fc);',\n//        '}',\n//\n//        'const float TWO_PI = 6.283185307179586;',\n//\n//        'void main() {',\n//\n//            //offsets\n//            'vec2 uv = vUv;',\n//\n//            //even strips\n//            //'float ys = steppedVal(fract(uv.y + iTime* V_SPEED + SEED),COUNT);',\n//            //'ys = steppedVal(uv.y + SEED,COUNT);',\n//\n//            //variable width strips\n//            'float n = noise1d(uv.y * slices + time * speedV * 3.0);',\n//            'float ns = steppedVal(fract(n  ),slices) + 2.0;',\n//\n//            'float nsr = random1d(ns);',\n//            //'gl_FragColor = vec4(vec3(nsr),1.0);', //debug\n//\n//            'vec2 uvn = uv;',\n//            'uvn.x += nsr * sin(time * TWO_PI + nsr * 20.0) * offset;',\n//\n//            'gl_FragColor = texture2D(tDiffuse, uvn);',\n//\n//\n//        '}'\n//\n//    ].join('\\n')\n//\n//};\n//\n///**\n//\n//    Smear shader\n//\n//    tDiffuse: \tbase texture\n//    flatten: amount to flatten into horiz stripes\n//    amount: color sample amount position\n//\n//    based on: https://www.airtightinteractive.com/demos/smear/\n//\n//    @author felixturner / http://airtight.cc/\n//\n// */\n//\n//THREE.SmearShader = {\n//\n//    uniforms: {\n//\n//        'tDiffuse': { type: 't', value: null },\n//        'amount': { type: 'f', value: 0.5},\n//        'time': { type: 'f', value: 0.5},\n//\n//\n//    },\n//\n//    vertexShader: [\n//\n//        'varying vec2 vUv;',\n//        'void main() {',\n//\n//            'vUv = uv;',\n//            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n//\n//        '}'\n//\n//    ].join('\\n'),\n//\n//    fragmentShader: [\n//\n//\n//        'const float TWO_PI = 6.283185307179586;',\n//\n//        'uniform sampler2D tDiffuse;',\n//        'uniform float amount;',\n//        'uniform float time;',\n//\n//        'varying vec2 vUv;',\n//\n//        'vec2 rotate2D(vec2 position, float theta){',\n//            'mat2 m = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) );',\n//            'return m * position;',\n//        '}',\n//\n//        'void main() {',\n//\n//            'vec2 p = vUv;',\n//\n//            //Displace image by its own rg channel\n//            'vec2 sPos = vUv;',\n//            'vec2 off = texture2D( tDiffuse, sPos ).rg - 0.5;',\n//\n//            //rotate\n//            'float ang = time * TWO_PI;',\n//            'off = rotate2D(off,ang);',\n//            'p += off * amount;',\n//\n//            'vec4 col = texture2D(tDiffuse,p);',\n//            'gl_FragColor = col;',\n//\n//\n//        '}'\n//\n//    ].join('\\n')\n//\n//};\n//\n// /**\n//\n//    Solarize Shader\n//    ported from https://www.interactiveshaderformat.com/sketches/390\n//\n// */\n//\n//THREE.SolarizeShader = {\n//\n//    uniforms: {\n//\n//        'tDiffuse': \t    { type: 't', value: null },\n//        'centerBrightness': { type: 'f', value: 0.5 },\n//        'powerCurve':       { type: 'f', value: 2.0 },\n//        'colorize':         { type: 'f', value: 0.1 },\n//\n//    },\n//\n//    vertexShader: [\n//\n//        'varying vec2 vUv;',\n//        'void main() {',\n//            'vUv = uv;',\n//            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n//        '}'\n//\n//    ].join('\\n'),\n//\n//    fragmentShader: [\n//\n//        'uniform sampler2D tDiffuse;',\n//\n//        'uniform float centerBrightness;',\n//        'uniform float powerCurve;',\n//        'uniform float colorize;',\n//\n//        'varying vec2 vUv;',\n//\n//        'vec3 rgb2hsv(vec3 c)\t{',\n//            'vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);',\n//            'vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);',\n//            'vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);',\n//            'float d = q.x - min(q.w, q.y);',\n//            'float e = 1.0e-10;',\n//            'return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);',\n//        '}',\n//\n//        'vec3 hsv2rgb(vec3 c)\t{',\n//            'vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);',\n//            'vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);',\n//            'return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);',\n//        '}',\n//\n//\n//        'void main() {',\n//\n//            'vec3 origCol = texture2D( tDiffuse, vUv ).rgb;',\n//\n//            //\tconvert to HSV\n//            'vec3 hslColor = rgb2hsv(origCol);',\n//            'vec3 outColor = hslColor;',\n//\n//            //\tadjust the brightness curve\n//            'outColor.b = pow(outColor.b, powerCurve);',\n//            'outColor.b = (outColor.b < centerBrightness) ? (1.0 - outColor.b / centerBrightness) : (outColor.b - centerBrightness) / centerBrightness;',\n//            'outColor.g = outColor.g * hslColor.b * colorize;',\n//\n//            //\tconvert back to rgb\n//            'outColor = hsv2rgb(outColor);',\n//\n//            //Additive Blend\n//            'gl_FragColor = vec4(outColor, 1.0);',\n//\n//        '}'\n//\n//    ].join('\\n')\n//\n//};\n//\n///**\n// * @author felixturner / http://airtight.cc/\n// * Radial sin /cos displacement\n// *\n// * Ported from http://uglyhack.appspot.com/videofx/\n// */\n//\n//THREE.WobbleShader = {\n//\n//    uniforms: {\n//\n//        'tDiffuse': { type: 't', value: null },\n//        'time':     { type: 'f', value: 0.0 },\n//        'strength':  { type: 'f', value: 0.001 },\n//        'size':  { type: 'f', value: 50.0 },\n//        'speed':  { type: 'f', value: 1.0 }\n//\n//    },\n//\n//    vertexShader: [\n//\n//        'varying vec2 vUv;',\n//\n//        'void main() {',\n//\n//            'vUv = uv;',\n//            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n//\n//        '}'\n//\n//    ].join('\\n'),\n//\n//    fragmentShader: [\n//\n//        'uniform sampler2D tDiffuse;',\n//        'uniform float time;',\n//\n//        'uniform float strength;',\n//        'uniform float size;',\n//        'uniform float speed;',\n//\n//        'varying vec2 vUv;',\n//\n//        'const float TWO_PI = 6.283185307179586;',\n//\n//        'void main() {',\n//\n//            'vec2 p = -1.0 + 2.0 * vUv;',\n//            'float pos = time * TWO_PI + length(p * size);',\n//            'gl_FragColor = texture2D(tDiffuse, vUv + strength * vec2(cos(pos), sin(pos)));',\n//        '}'\n//\n//    ].join('\\n')\n//\n//};\n"]}